@using Confluent.Kafka
@using Confluent.Kafka.Admin
@using Kafkaf.Config
@using Microsoft.Extensions.Caching.Memory
@using Microsoft.Extensions.Options

@page "/{clusterIdx:int}/topics"
@rendermode InteractiveServer

@inject IOptions<List<ClusterConfigOptions>> ClusterOptions;
@inject IMemoryCache MemoryCache

<PageTitle>Topics: List</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="col">
            <h1>Topics: List</h1>
        </div>
        <div class="col text-end">            
            <NavLink class="nav-link" href="@($"/{clusterIdx}/topics/create")">                
                <button class="btn btn-primary">Add a Topic</button>
            </NavLink>
        </div>
    </div>
</div>

<div class="card">
  <div class="card-header">
    <ul class="list-group list-group-horizontal">
        <li class="list-group-item col-4">
            <InputText @bind-Value="SearchTopicName" 
                       class="form-control" 
                       placeholder="Search by Topic Name">
            </InputText>
        </li>
        <li class="list-group-item">
            <button class="btn btn-primary" @onclick="() => { SearchTopicName = null; }">Clear</button>
        </li>
        <li class="list-group-item">
            <label>Show Internal Topics</label>
            <InputCheckbox @bind-Value="ShowInternalTopics" />
        </li>
    </ul>
    <br />
  </div>
  <div class="card-body">
      <EditForm Model="@SelectedTopics">
            <table class="table">
                <thead>
                    <tr>
                        <th>&nbsp;</th>
                        <th>Topic Name</th>
                        <th>Partitions</th>
                        <th>Out of sync replicas</th>
                        <th>Replication Factor</th>
                        <th>Number of messages</th>
                        <th>Size</th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var topic in Topics)
                    {
                        var isChecked = SelectedTopics.Contains(topic.TopicName);

                        <tr>
                            <td> @isChecked </td>
                            <td>@topic.TopicName</td>
                            <td>@topic.Partitions</td>
                            <td>@topic.OutOfSyncReplicas</td>
                            <td>@topic.ReplicationFactor</td>
                            <td>@topic.NumberOfMessages TODO</td>
                            <td>@topic.Size TODO</td>
                        </tr>
                    }
                </tbody>
            </table>
        </EditForm>
    
  </div>
  <div class="card-footer">      
        cluster no: #@clusterIdx        
  </div>
</div>


@code {
    public struct TopicsListRow
    {
        public string TopicName { get; set; }
        public int Partitions { get; set; }
        public int OutOfSyncReplicas { get; set; }
        public string ReplicationFactor { get; set; }
        public int NumberOfMessages { get; set; }
        public int Size { get; set; }        

        public TopicsListRow(TopicMetadata meta)
        {
            TopicName = meta.Topic;
            Partitions = meta.Partitions.Count;

            if (meta.Partitions.Count > 0)
            {
                ReplicationFactor = meta.Partitions[0].Replicas.Length.ToString();
                OutOfSyncReplicas = meta.Partitions
                    .Sum(partition => partition.Replicas[0] - partition.InSyncReplicas[0]);
            }
            else
            {
                ReplicationFactor = "0";
                OutOfSyncReplicas = 0;
            }

            NumberOfMessages = 0; // TODO
            Size = 0; //TODO
        }
    }

    private List<string> SelectedTopics = new();
    private List<TopicsListRow> _topics = new();
    private bool _showInternalTopics = true;
    private string? _searchTopicName = null;

    [Parameter]
    public int clusterIdx { get; set; }

    public List<TopicsListRow> Topics = new();

    public bool ShowInternalTopics 
    { 
        get => _showInternalTopics; 
        set
        {
            _showInternalTopics = value;
            UpdateTopics();
        }
    }

    public string? SearchTopicName
    {
        get => _searchTopicName;
        set
        {
            _searchTopicName = value;
            UpdateTopics();
        }
    }

    protected override async Task OnInitializedAsync()
    {        
        var clusterConfig = ClusterOptions.Value[clusterIdx - 1];
        var meta = await MemoryCache.GetOrCreateAsync(
            clusterConfig.CacheKey(),
            async cacheEntry =>
            {
                cacheEntry.SlidingExpiration = TimeSpan.FromMinutes(60);

                return await KafkaUtils.GetMetadata(clusterConfig);
            });

        // TODO: handle null
        _topics = meta!.Topics
            .Select(meta => new TopicsListRow(meta))
            .ToList();

        UpdateTopics();

        await base.OnInitializedAsync();
    }       

    private void UpdateTopics()
    {
        var qry = _topics.AsQueryable();

        if (!_showInternalTopics)
        {
            qry = qry.Where(topic => !topic.TopicName.StartsWith("__"));
        }

        if (!string.IsNullOrEmpty(_searchTopicName))
        {
            qry = qry.Where(topic => topic.TopicName.Contains(_searchTopicName, StringComparison.InvariantCultureIgnoreCase));
        }

        Topics = qry.ToList();
    } 

    
}

@using Confluent.Kafka
@using Confluent.Kafka.Admin
@using Kafkaf.Config
@using Kafkaf.ViewModels
@using Microsoft.Extensions.Caching.Memory
@using Microsoft.Extensions.Options

@page "/{clusterIdx:int}/topics"
@rendermode InteractiveServer

@inject IOptions<List<ClusterConfigOptions>> ClusterOptions;
@inject IMemoryCache MemoryCache

<PageTitle>Topics: List</PageTitle>

<div class="container-fluid">
	<div class="row">
		<div class="col">
			<h1>Topics: List</h1>
		</div>
		<div class="col text-end">
			<NavLink class="nav-link" href="@($"/{clusterIdx}/topics/create")">
				<button class="btn btn-primary">Add a Topic</button>
			</NavLink>
		</div>
	</div>
</div>

<EditForm Model="@this">
	<div class="container-fluid">
		<div class="row">
			<div class="col-4">
				<div class="input-group mb-3">
					<InputText class="form-control" placeholder="Search by Topic Name" @bind-Value="SearchTopicName" />
					<div class="input-group-append">
						<button class="btn btn-outline-secondary" type="button" @onclick="() => SearchTopicName = null">x</button>
					</div>
				</div>
			</div>
			<div class="col-8">
				<div class="form-check form-switch">
					<InputCheckbox class="form-check-input"
								   id="flexSwitchCheckDefault"
								   @bind-Value="ShowInternalTopics" />

					<label class="form-check-label"
						   for="flexSwitchCheckDefault">Show Internal Topics</label>
				</div>
			</div>
		</div>
	</div>

	<div class="container-fluid">
		<div class="row">
			<div class="btn-group-sm col-8" role="group" aria-label="Actions for selected topis">
				<button type="button"
						class="btn btn-outline-secondary me-1"
						disabled="@(0 == @SelectedTopics.Count)"
						@onclick="HandleDeleteTopics">
					Delete selected topics
				</button>

				<button type="button"
						class="btn btn-outline-secondary me-1"
						disabled="@(0 == @SelectedTopics.Count)"
						@onclick="HandleCopyTopics">
					Copy selected topics
				</button>

				<button type="button"
						class="btn btn-outline-secondary me-1"
						disabled="@(0 == @SelectedTopics.Count)"
						@onclick="HandlePurgeMessages">
					Purge messages of selected topics
				</button>
			</div>
		</div>
	</div>

	<table class="table mt-4">
		<thead>
			<tr>
				<th>&nbsp;</th>
				<th>Topic Name</th>
				<th>Partitions</th>
				<th>Out of sync replicas</th>
				<th>Replication Factor</th>
				<th>Number of messages</th>
				<th>Size</th>
			</tr>
		</thead>
		<tbody>
			@foreach (var topic in Topics)
			{
				var isChecked = SelectedTopics.Contains(topic.TopicName);

				<tr>
					<td>
						<input type="checkbox"
							   checked="@isChecked"
							   @onchange="e => HandleTopicChecked(e, topic.TopicName)" />
					</td>
					<td>@topic.TopicName</td>
					<td>@topic.Partitions</td>
					<td>@topic.OutOfSyncReplicas</td>
					<td>@topic.ReplicationFactor</td>
					<td>@topic.NumberOfMessages TODO</td>
					<td>@topic.Size TODO</td>
				</tr>
			}
		</tbody>
	</table>
</EditForm>


<p>
	cluster no: #@clusterIdx
	selected topics: @SelectedTopics.Count
</p>


@code {

	[Parameter]
	public int clusterIdx { get; set; }

	private List<string> SelectedTopics = new();

	private List<TopicsListViewModel> _topics = new();
	private List<TopicsListViewModel> Topics = new();

	private bool _showInternalTopics = true;
	private bool ShowInternalTopics
	{
		get => _showInternalTopics;
		set
		{
			_showInternalTopics = value;
			UpdateTopics();
		}
	}

	private string? _searchTopicName = null;
	public string? SearchTopicName
	{
		get => _searchTopicName;
		set
		{
			_searchTopicName = value;
			UpdateTopics();
		}
	}

	protected override async Task OnInitializedAsync()
	{
		var clusterConfig = ClusterOptions.Value[clusterIdx - 1];
		var meta = await MemoryCache.GetOrCreateAsync(
			clusterConfig.CacheKey(),
			async cacheEntry =>
			{
				cacheEntry.SlidingExpiration = TimeSpan.FromMinutes(60);

				return await KafkaUtils.GetMetadata(clusterConfig);
			});

		// TODO: handle null
		_topics = meta!.Topics
			.Select(meta => new TopicsListViewModel(meta))
			.ToList();

		UpdateTopics();

		await base.OnInitializedAsync();
	}

	private void UpdateTopics()
	{
		var qry = _topics.AsQueryable();

		if (!_showInternalTopics)
		{
			qry = qry.Where(topic => !topic.TopicName.StartsWith("__"));
		}

		if (!string.IsNullOrEmpty(_searchTopicName))
		{
			qry = qry.Where(topic => topic.TopicName.Contains(_searchTopicName, StringComparison.InvariantCultureIgnoreCase));
		}

		Topics = qry.ToList();
	}

	private void HandleTopicChecked(ChangeEventArgs e, string topicName)
	{
		if (e.Value is true)
		{
			SelectedTopics.Add(topicName);
		}
		else
		{
			SelectedTopics.Remove(topicName);
		}
	}

	private void HandleDeleteTopics()
	{

	}

	private void HandleCopyTopics()
	{

	}

	private void HandlePurgeMessages()
	{

	}
}

@using Confluent.Kafka
@using Confluent.Kafka.Admin
@using Kafkaf.Web
@using Kafkaf.Web.Config
@using Kafkaf.Web.ViewModels
@using Microsoft.Extensions.Caching.Memory
@using Microsoft.Extensions.Options

@page "/{clusterIdx:int}/topics"
@rendermode InteractiveServer

@inject IOptions<List<ClusterConfigOptions>> ClusterOptions;
@inject IMemoryCache MemoryCache


<PageTitle>Topics: List</PageTitle>

<div class="container-fluid">
	<div class="row">
		<div class="col">
			<h1>Topics: List</h1>
		</div>
		<div class="col text-end">			
			<NavLinkTopics ClusterIdx="@clusterIdx" Text="Add a Topic" TopicId="create" />
		</div>
	</div>
</div>

<EditForm Model="@this">
	<Alert Title="Error!" Notice=@_errorNotice AlertStyle=BootstrapAlertStyle.Danger></Alert>
	<Alert Title="Success!" Notice=@_successNotice AlertStyle=BootstrapAlertStyle.Success />
		
	<div class="container-fluid">		
		<div class="row">			
			<div class="col-4">
				<div class="input-group mb-3">
					<InputText class="form-control" placeholder="Search by Topic Name" @bind-Value="SearchTopicName" />
					<div class="input-group-append">
						<button class="btn btn-outline-secondary" type="button" @onclick="() => SearchTopicName = null">x</button>
					</div>
				</div>
			</div>
			<div class="col-8">
				<div class="form-check form-switch">
					<InputCheckbox class="form-check-input"
								   id="flexSwitchCheckDefault"
								   @bind-Value="ShowInternalTopics" />

					<label class="form-check-label"
						   for="flexSwitchCheckDefault">Show Internal Topics</label>
				</div>
			</div>
		</div>
	</div>

	
	@if (_loading)
	{
		<div class="text-center">
			<div class="spinner-border" role="status">
				<span class="sr-only">Loading...</span>
			</div>
		</div>

	} 
	else
	{
		<div class="container-fluid">
			<div class="row">
				<div class="btn-group-sm col-8" role="group" aria-label="Actions for selected topis">
					<button type="button"
							class="btn btn-outline-secondary me-1"
							disabled="@(0 == @SelectedTopics.Count)"
							@onclick="DeleteTopicsAsync">
						Delete selected topics
					</button>

					<button type="button"
							class="btn btn-outline-secondary me-1"
							disabled
							@onclick="HandleCopyTopics">
						Copy selected topics (TODO)
					</button>

					<button type="button"
							class="btn btn-outline-secondary me-1"
							disabled="@(0 == @SelectedTopics.Count)"
							@onclick="PurgeMessagesAsync">
						Purge messages of selected topics
					</button>
				</div>
			</div>
		</div>
	}
	
	<table class="table mt-4">
		<thead>
			<tr>
				<th>&nbsp;</th>
				<th>Topic Name</th>
				<th>Partitions</th>
				<th>Out of sync replicas</th>
				<th>Replication Factor</th>
				<th>Number of messages</th>
				<th>Size</th>
			</tr>
		</thead>
		<tbody>
			@foreach (var topic in Topics)
			{
				var isChecked = SelectedTopics.Contains(topic.TopicName);

				<tr>
					<td>
						<input type="checkbox"
							   checked="@isChecked"
							   @onchange="e => HandleTopicChecked(e, topic.TopicName)" />
					</td>
					<td>						
						<NavLinkTopics ClusterIdx="@clusterIdx" 
									    ButtonStyle="BootstrapButtonStyle.Link" 
										Text="@topic.TopicName"
									    TopicId=@($"{topic.TopicName}") />
					</td>
					<td>@topic.Partitions</td>
					<td>@topic.OutOfSyncReplicas</td>
					<td>@topic.ReplicationFactor</td>
					<td>@topic.NumberOfMessages TODO</td>
					<td>@topic.Size TODO</td>
				</tr>
			}
		</tbody>
	</table>
</EditForm>


@code {

	[Parameter]
	public int clusterIdx { get; set; }

	private bool _loading = false;

	private List<string> SelectedTopics = new();

	private List<TopicsListViewModel> _topics = new();
	private List<TopicsListViewModel> Topics = new();

	private bool _showInternalTopics = true;
	private bool ShowInternalTopics
	{
		get => _showInternalTopics;
		set
		{
			_showInternalTopics = value;
			UpdateTopics();
		}
	}

	private string? _searchTopicName = null;
	public string? SearchTopicName
	{
		get => _searchTopicName;
		set
		{
			_searchTopicName = value;
			UpdateTopics();
		}
	}

	private string? _errorNotice;
	private string? _successNotice;

	protected override async Task OnInitializedAsync()
	{
		var clusterConfig = ClusterOptions.Value[clusterIdx - 1];
		var meta = await MemoryCache.GetOrCreateAsync(
			clusterConfig.CacheKey(),
			async cacheEntry =>
			{
				cacheEntry.SlidingExpiration = TimeSpan.FromMinutes(60);

				return await KafkaUtils.GetMetadata(clusterConfig);
			});

		// TODO: handle null
		_topics = meta!.Topics
			.Select(meta => new TopicsListViewModel(meta))
			.ToList();

		UpdateTopics();

		await base.OnInitializedAsync();
	}

	private void UpdateTopics()
	{
		var qry = _topics.AsQueryable();

		if (!_showInternalTopics)
		{
			qry = qry.Where(topic => !topic.TopicName.StartsWith("__"));
		}

		if (!string.IsNullOrEmpty(_searchTopicName))
		{
			qry = qry.Where(topic => topic.TopicName.Contains(_searchTopicName, StringComparison.InvariantCultureIgnoreCase));
		}

		Topics = qry.ToList();
	}

	private void HandleTopicChecked(ChangeEventArgs e, string topicName)
	{
		if (e.Value is true)
		{
			SelectedTopics.Add(topicName);
		}
		else
		{
			SelectedTopics.Remove(topicName);
		}
	}

	private Task DeleteTopicsAsync() => WithLoadingAsync(KafkaUtils.DeleteTopics);	

	private Task PurgeMessagesAsync() => WithLoadingAsync(KafkaUtils.PurgeMessages);

	private void HandleCopyTopics()
	{
		// TODO
	}

	private async Task WithLoadingAsync(WithClusterConfigAndTopicsAsyncDelegate del)
	{
		var clusterConfig = ClusterOptions.Value[clusterIdx - 1];

		_errorNotice = null;
		_successNotice = null;
		_loading = true;
		try
		{
			await del(clusterConfig, SelectedTopics);

			_successNotice = "Sucess";
		}
		catch(Exception e)
		{			
			_errorNotice = e.Message;
		}
		finally
		{
			_loading = false;
		}
	}

	
}
